for repl: while instead of main inside main as recursion may cause buffer overflow if it runs too long.
exit 0 check to break loop
so flush literally flushes the buffer which had write's args and without it stdout would have waited till program execution completion or \n appears
split command into strings in a list 
builtin dictionary better than switch or if. then only one if cmd is in dictionary or not
lamda: one line functions : lamda *args: expression and *args will take a string list > to tuppe *_ to ignore extra args

path : env variable : stores dirs containing executable programs. 
program received> search dirs listed in path separated by colon> print first finding path/to/cmd else not.
walrus op > := assign and check
shutil.which("cmd") > strings the dirs in PATH variable of the os's shell 
shutil module > high level file operations like copy, move, delete, etc.

subprocess > start new process, connect to input/output/error pipes, and obtain return codes.
.run > run command with args, wait to complete, returns comp proc instance stdin &stderr need to be set to subprocess.PIPE to capture output 
tester prepends custom path to tester's OS PATH 

cd function:
expanduser with ~ It checks the value of the HOME environment variable (using os.environ["HOME"]) and replaces the tilde with the user's home directory path then os.chdir changes the current working directory to the specified path.

//builtin refresher
The shell parses the command and arguments.
It looks up the command in BUILTINS and calls the function with the arguments.
Pythonâ€™s *args syntax handles the unpacking, so your builtin functions receive the right arguments automatically.

context manager: with open or redirect_stdout
The with statement calls the file object's __enter__ method at the start (opening the file), and its __exit__ method at the end (closing the file).

//redirection parsing
scan all args for >, >>, <, 1> (and 2> if needed). only the last one of each type is used, like bash. skip both the operator and its filename in the loop (i += 2). strip quotes from filenames after redirection ops so "file.txt" works as file.txt

//data-driven redirection parsing
use an ops dict mapping operators (>, 1>, >>, <, 2>, 2>>) to target fields and append flags. scan args with a while loop and manual i += 2 to skip operator+filename. last redirection wins, strip wrapping quotes, leave filtered args for execution.

//dynamic redirection contexts
use contextlib.ExitStack to open and register stdin/stdout/stderr files dynamically. enter redirect_stdout and redirect_stderr for builtins or pass file handles to subprocess for externals. on stack exit all files close and contexts revert automatically.

//redirection for builtins
if redirection is set, use context manager (with redirect_stdout) to temporarily send output to file for builtins like echo, pwd, etc. so echo hi > file.txt works for both builtins and external commands.

//context manager protocol (resouce that needs to be cleaned up after use)
an object that implements __enter__ and __exit__ methods can be used with the with statement. __enter__ is called at the start of the block,and __exit__ at the end. 
this allows for resource man like opening files, redirecting output. like redirect_stdout temporarily sends output to a file, and when the block ends, it restores the original stdout. this is useful for builtins like echo or pwd that need to write to a file instead of the console.
ex:
with CM() as cm:
   # inside block: CM().__enter__ has run
#ends with block, CM().__exit__ runs automatically, restoring original state
syntactic sugar for try/finally
cm = CM()
try:
   cm.__enter__()
finally:
   cm.__exit__(None, None, None)

//ExitStack for dynamic contexts
contextlib.ExitStack allows you to manage multiple context managers dynamically. you can enter and exit multiple
context managers within a single with block. this is useful when you need to open multiple files or redirect output dynamically based on conditions.
lifo order: the last entered context manager is the first to exit, ensuring proper cleanup.
ex:
class ExitStack:
    def __init__(self):   self._exit_callbacks = []
    def enter_context(self, cm):
        result = cm.__enter__()
        self._exit_callbacks.append(cm.__exit__)
        return result
    def __exit__(self, exc_type, exc, tb):
        # call all callbacks in reverse to unwind
        for cb in reversed(self._exit_callbacks):
            cb(exc_type, exc, tb)
//exitstack implements stack with 1 empty list to hold exit callbacks. enter_context calls __enter__ on the context manager, stores its __exit__ in the stack, and returns the result. __exit__ calls all stored callbacks in reverse order .


from contextlib import ExitStack

with ExitStack() as stack:
    f1 = stack.enter_context(open('out1.txt', 'w'))
    f2 = stack.enter_context(open('out2.txt', 'w'))
    # both files auto-close when block ends

    # readline insights:
    readline enables tab completion and history for interactive shells. Use readline.set_completer to define custom completions and readline.parse_and_bind("tab: complete") to bind Tab for completion. Save/load history with readline.write_history_file/read_history_file.

//Stateful Bash-like Completer Class
Encapsulates state (last_prefix, tab_count) in a class to avoid globals.
__init__ sets up initial state (commands, counters).
__call__ method makes the instance callable like a function, which readline.set_completer expects.
reset method for the pre_input_hook to clear state on new input.
Double-TAB Logic:
1. First TAB on multiple matches -> ring bell, save state (prefix and tab_count=1).
2. Second TAB -> print sorted matches, reprint prompt, insert common prefix with readline.insert_text and redisplay.

so readline provides an inbuilt register for the completion display matches hook but just the hook we have to define
