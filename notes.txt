for repl: while instead of main inside main as recursion may cause buffer overflow if it runs too long.
exit 0 check to break loop
so flush literally flushes the buffer which had write's args and without it stdout would have waited till program execution completion or \n appears
split command into strings in a list 
builtin dictionary better than switch or if. then only one if cmd is in dictionary or not
lamda: one line functions : lamda *args: expression and *args will take a string list > to tuppe *_ to ignore extra args

path : env variable : stores dirs containing executable programs. 
program received> search dirs listed in path separated by colon> print first finding path/to/cmd else not.
walrus op > := assign and check
shutil.which("cmd") > strings the dirs in PATH variable of the os's shell 
shutil module > high level file operations like copy, move, delete, etc.

subprocess > start new process, connect to input/output/error pipes, and obtain return codes.
.run > run command with args, wait to complete, returns comp proc instance stdin &stderr need to be set to subprocess.PIPE to capture output 
tester prepends custom path to tester's OS PATH 

cd function:
expanduser with ~ It checks the value of the HOME environment variable (using os.environ["HOME"]) and replaces the tilde with the user's home directory path then os.chdir changes the current working directory to the specified path.

//builtin refresher
The shell parses the command and arguments.
It looks up the command in BUILTINS and calls the function with the arguments.
Pythonâ€™s *args syntax handles the unpacking, so your builtin functions receive the right arguments automatically.
